[[{"l":"Welcome","p":["Warthog is an experimental L1-cryptocurrency implementation without specific focus. This project is not a dumb fork of something else. It was developed completely from scratch!","Warthog's Janushash mining algorithm is unique across the crypto space, it is the world's first Proof of Balanced Work (PoBW) algorithm, which requires CPU and GPU hash power for mining.","The core repository offers two applications:","Node","Command line Wallet","Furthermore there are two third-party wallets:","wart-wallet(open source)","Warthog-network-dapp(open source)","You can join the Warthog community on Discord."]},{"l":"Starting a node","p":["Download the latest version from here.","The node does not have external dependencies, it can be started via command line:","The node starts syncing. The node needs to be running and synced while we are using the wallet and miner."]},{"l":"Using the CLI Wallet","p":["We explain how to use the command line wallet. If you don't know how to use the command line, you should use a graphical wallet such as wart-wallet or Warthog-network-dapp.","Let's create a new wallet","A new wallet called wallet.json file is created. It is not encrypted and other malicious programs you run on your computer can steal it. Back it up. Don't show it to anyone. The private key can be used to restore the wallet. To print your address use the command","To check your balance use","You can send some coins with","The wallet asks for the address you want to send to, the fee and the amount. You can type in values like these: Then confirm with \"y\" and press enter. Of course you cannot send because your wallet address has no coins yet.","For more information on how to use the wallet read the --help section:"]},{"l":"Mining","p":["Mining Warthog's Janushash algorithm requires both, a good CPU and a GPU. Solo and pool miners can be found here:","Janusminer(open source)","We have a guide on how to install OpenCL: Welcome"]}],[{"l":"Links","p":["Algorithm whitepaper"]},{"l":"Socials","p":["Discord","Telegram","Bitcointalk","Reddit"]},{"l":"Explorers","p":["wartscan)"]},{"l":"Pools","p":["acc-pool","WartPool","WoolyPooly"]},{"l":"Miners","p":["Janusminer(open source)","BzMiner(closed source)"]},{"l":"Wallets","p":["wart-wallet(open source)","Warthog-network-dapp(open source)"]},{"l":"Exchanges","p":["Exbitron","Xeggex","TradeOgre"]},{"i":"tutorials--other-content","l":"Tutorials / Other Content","p":["Warthog Presentation by Onur Akbaşoğlu (in turkish)","Mining tutorial by BearMarketMiner (in english)","Mining tutorial by Luketherock868 Mining (in english)","Mining tutorial by Makertronic (in french)","Janushash Calculator by Krzys","NOTE:","If a link is missing, don't hesitate to make a PR or tell us on discord."]}],[{"l":"Janushash"},{"l":"Proof of Balanced Work"},{"l":"Introduction","p":["Compared to classical Proof of Work, the class of Proof of Balanced Work (PoBW) algorithms is quite a different beast. Instead of only employing one hash function they combine multiple hash functions in a multiplicative way. The mathematical theory of considering a multiplicative combination of hashes, i.e. hash products, was established in this paper for Warthog and currently there is no other crypto project using Proof of Balanced Work for consensus.","Combining different hash functions multiplicatively has the advantage that","different hash functions can be mined in parallel devices at different hashrates using a multi-stage filtering approach and","efficient mining requires mining of all involved algorithms for each block in contrast to previous failed attempts to construct multi-algorithm block chains by using individual difficulties for each algorithm (Myriad Coin, DigiByte, Verge). For example Verge could be hacked by focusing only on one algorithm."]},{"i":"janushash-1","l":"Janushash","p":["Essentially, Proof of Balanced Work algorithms are simply the multiplicative combinations of existing hash functions. Warthog Janushash algorithm combines two hash functions:","triple Sha256 (Sha256t) and","Verushash v2.1"]},{"l":"Balancing","p":["Energy-efficient mining of Proof of Balanced Work algorithms requires finding a good balance between Sha256t and Verushash hashrates. The best combination depends on hardware and energy cost but it is clear that mining without a GPU or with a weak CPU won't be competitive. The balancing requirement coined the name \"Proof of Balanced Work\"."]},{"l":"Hashrate Decentralization"},{"l":"Fighting Farms","p":["Interestingly, the Janushash algorithm keeps away both, GPU farms and CPU farms:","GPU farms usually save on the CPU side, because CPU performance is not relevant for mining GPU algorithms. Therefore such farms perform poorly on Janushash. GPU farm owners would need to make significant investments in efficient and performant motherboards and CPUs to improve their GPU/CPU balance for efficiently mining Janushash.","CPU farms perform very poorly on Janushash because of the lack of accelerated triple Sha256 hash evaluation. The same applies to most botnets.","This means large mining farms and botnets play a much smaller role in Warthog than they do in other proof of work cryptocurrencies, which increases decentralization of hashrate."]},{"i":"satoshis-vision","l":"Satoshi's vision","p":["Originally, Satoshi Nakamoto had an idealized hope for mining being a democratized way of establishing consensus. This can be seen for example in his famous whitepaper:","From this article about Laszlo Hanyecz's correspondence with Satoshi we can observe that Satoshi was not amazed about the fact that GPU mining would disrupt this idealized hope:","\"One of the first emails Satoshi had sent the man was in response to him describing his proposed GPU miner. Mainly, Satoshi was none-too-pleased, asking Hanyecz to slow down with this.\"","\"Satoshi explained that, at the time, one of the biggest attractions possible is the fact that anyone can download Bitcoin and start mining with their laptops. Without that, it wouldn't have gained as much traction.\"","He knew that with the advent of GPU mining, many CPU miners would be kicked out of the network, which would be against his vision of fair, equal and decentralized mining. Therefore he hoped to delay this as long as possible.","We all know that his hopes have not been fulfilled, today Bitcoin is mined on specialized expensive hardware and only those with access to this hardware can participate in mining. After all, Satoshi was not able to solve the issue of centralized mining.","We are confident that the use of Proof of Balanced Work solves this issue to a large extent when the combined hash functions are carefully selected. In Janushash, the two hash functions Sha256t and Verushash where chosen to require a GPU and a CPU connected with sufficiently large bandwidth. This was done to target typical gaming PCs. As described above, with this choice farms cannot easily join the network without being forced to make additional investments just for mining Warthog. This democratizes mining Warthog and brings it closer to Satoshi's vision."]},{"l":"ASIC Resistance","p":["As technology advances, so does specialized mining hardware, especially when potential profits are high. There is nothing that can be done against this fact. However there are three reasons why Warthog is more robust against ASIC threats than other PoW cryptocurrencies:"]},{"l":"Inherited ASIC Resistance","p":["When it comes to ASIC resistance, Proof of Balanced Work is stronger than its strongest ingredient. To accelerate mining, an ASIC would need to be able accelerate computation of all combined hash functions to avoid a bottleneck effect. In addition an ASIC would need enough bandwidth between the hardware sections computing different hash functions as well as calibration and tuning to optimize their intercommunication and coordination.","In particular, Janushash inherits ASIC-resistance from Verushash v2.1 which is currently mined on CPUs and GPUs, but not on FPGAs/ASICs, and the need to also require SHA256t hashrate makes Janushash even more ASIC-resistant."]},{"l":"Detection of suspicious hashrate","p":["In traditional Proof of Work networks we only have one marker to analyze network hashrate, namely the network difficulty. It can be used to estimate the total hashrate of all miners in the network. However we cannot tell whether some actors use specialized hardware to gain an unfair advantage over normal miners.","Janushash however combines two hash functions and harnessing the probability theory and statistics, we can extract information about the Sha256t/Verushash hashrate ratio used to mine a block. This information is shown publicly in the blockchain explorer:","In addition to the network difficulty, this second marker provides useful information on the network hashrate: It allows to spot suspicious hashrate immediately. In Warthog it is much more difficult for ASICs to stay undetected because they must not only successfully mine blocks, but also mimic the hashrate ratio used by honest miners. This is another unique property of Proof of Balanced Work."]},{"l":"Simple Algorithm Adaption","p":["The fundamental reason for the favorable properties of the Janushash algorithm is not the particular choice of the combined hash functions itself, but the choice to rely on Proof of Balanced Work to combine different hash functions multiplicatively. This means that if ASICs really join the network one day, we can simply exchange the combined hash functions, for example for Blake3 on GPU and RandomX on CPU, while preserving all the advantages listed here. Combining established hash functions allows the creation new algorithms fast while benefiting from their maturity and proven properties at the same time. This allows Warthog to adapt quickly when needed."]},{"l":"Make mining great again","p":["Warthog tries to revive the good old days when mining was fun. The unique properties of the Janushash algorithm help to achieve this goal:"]},{"l":"Escaping one-dimensional mining boredom","p":["In a way, traditional mining in cryptocurrency is one-dimensional, the goal is simply to find the best hardware for evaluating some hash function. In contrast, mining Warthog is two-dimensional: there are two hash functions Sha256t and Verushash v2.1, and both hashrates are relevant for the mining efficiency. This leads to much more versatile options and motivates miners to experiment with endless hardware setups. Vivid discussions about the best combinations bring Warthog mining to life."]},{"i":"robin-hood-steal-from-the-farms-to-feed-the-gamers","l":"Robin Hood: Steal from the farms to feed the gamers","p":["As explained above, established farms require substantial investments in order to mine Warthog efficiently and making such investment only for mining Warthog might not be reasonable for most farms.","On the other hand gamers usually have systems with modern platforms and CPUs paired with sufficiently good GPUs to mine Warthog efficiently. Since farms and botnets are less of a direct competitor in Warthog than they are in other Proof of Work cryptocurrencies, this will reflect in increased mining returns for the average gamer or miner, which will in turn contribute to Warthog's popularity."]},{"l":"TLDR Summary","p":["Proof of Balanced Work (PoBW) was invented for Warthog and might have a tremendous impact on the whole crypto space.","Janushash is a PoBW algorithm combining Sha256t and Verushash v2.1","Efficiently mining Janushash requires both, a GPU and a CPU.","Miners have to find a good balance of GPU and CPU hardware. Too many GPUs paired with one CPU won't perform well.","GPU farms cannot easily compete because they usually have weak CPUs. They would need to adapt their motherboards and CPUs just for mining Warthog.","CPU farms and botnets cannot compete because they can't compute Sha256t reasonably fast.","Warthog will be interesting for Gamers because Farms won't compete so fiercely.","Hashrate balance of the two algorithms can be observed from mined blocks, such that additional suspicious hashrate of specialized mining hardware can be easily spotted in the network.","The above observations imply greater decentralization.","Due to these properties, Warthog's mining algorithm comes closer to Satoshi's original vision of democratized mining being than any other cryptocurrency."]}],[{"l":"Hashes as Numbers","p":["Each hash (32 byte hex string) can be interpreted as a number in the interval [0,1).","For example the hash FFFF...FFFF would correspond to 1-2^ 256 which is almost 1 and","the hash 0000...0000 would correspond to 0.","Note: A hash cannot correspond to exactly 1 but almost 1.","For a block header h we denote","the verus hash interpreted as a number in [0,1) by X(h) and","the triple sha256 hash interpreted as a number in [0,1) by Y(h).","We define the Janushash number J(h) = X(h)Y(h)^{0.7}.","Similar to above where we converted a hash to a number we can do the reverse, i.e. interpret J(h) as a hash, this hash is the Janushash but we will never compute it or work with it, instead we will solely consider the number representation J(h). All theory works with numbers, so implementation only needs to convert hashes to numbers, but not numbers to hashes For convenience we will call the Janushash number also Janushash.","To represent a small number as a hash, one might require more than 32 digits, there exist transcendental numbers which even require infinite digits to be represent exactly. However this is not of interest for us."]}],[{"l":"Condition to solve a block","p":["For target \\tau\\in[0,1] we define the following two conditions a header h must satisfy to have a valid Proof of Balanced Work:","The Sha256t hash must not be too small: Y(h) \\ge c for some constant c=0.005","The Janushash must be below the target: J(h) < \\tau."]},{"i":"implementation","l":"Implementation:","p":["The function to check for valid Proof of Balanced Work can be implemented as follows:","The CustomFloat class has it's own Repository here. It is a portable floating point representation with math functions ( log2, pow2, pow) and supports:","Conversion of a hash into CustomFloat number representation.","Multiplication","Raising a number to some exponent","The use of CustomFloat is necessary since C math library functions cannot be used in consensus-critical parts of a cryptocurrency. This way portatility is guaranteed."]}],[{"l":"Mining","p":["Optimally mining janushash exhausts both, a system's CPU and GPU to their limits. GPU is more efficient at Sha256t computations while CPU is more efficient at Verushash v2.1. Since Sha256t hashrate will usually be larger than Verushash v2.1 hashrate by orders of magnitude, it is important to decide optimally on which headers we evaluate the Verushash v2.1 hash function.","Since Sha256t and Verushash v2.1 are different proper hash functions the result of one does not correlate with the result of the other (mathematically we can model the two hash functions' outcomes as independent). Therefore to minimize the janushash value (which needs to be below the target to mine a block)","verushash(header)*sha256t(header)^0.7","it is best to evaluate verushash on the headers with smallest sha256t values that are still larger than the constant c to match the first mining condition above:","Sha256t(header) > c for some hard-coded constant c.","In particular out of the many GPU computed sha256t hashes we need to select the smallest that are greater than c. We select just as many as the CPU can handle.","This gives us the following approach:"]},{"l":"Mining Approach","p":["Mine sha256t of headers on GPU","Send those headers with sha256t > c and smaller than c + hr_CPU/hr_GPU into a queue that is processed by CPU to evaluate verushash on them.","Compute Verushash v2.1 on these headers","Evaluate janushash number representation verushash(header)*sha256t(header)^0.7 and check if it is smaller than the target t.","Above in 2. we use the quotient of CPU and GPU hashrates on verushash, sha256t respectively. The idea behind the band [c, c+hr_CPU/hr_GPU] is that on average, the number of sha256t hashes that fall into this band will be at rate hr_CPU, so this strategy will produce header candidates in the CPU queue at exactly the rate the CPU can handle.","To evaluate janushash number representation in 4. above, we should copy not only the headers but also the first 4 bytes of the evaluated sha256t hash from GPU device to host memory. Otherwise we would need to evaluate sha256t(header) again."]}],[{"l":"Preliminaries"},{"l":"Distribution of Hashes","p":["A proper hash function should be random in the sense that each output bit cannot be predicted from the input and also cannot be predicted from other bits in its output. Therefore with the interpretation of a hash as a number in [0,1) we can model the Verushash v2.1 X(h) and the Sha256t Y(h) of a header as samples of uniform random variable on [0,1]. Since we use two different hash functions we can model the vector (X(h),Y(h)) as two independent realization of a uniform random variable on [0,1]. This means that the joint distribution is the product measure, i.e. the uniform distribution on [0,1]^2.","We therefore define the random vector(X,Y) to have this uniform probability distribution on [0,1]. Keep in mind that this random vector just models the Verushash v2.1 and Sha256t hashes (interpreted as numbers in [0,1]) of a block header in a probability-theoretic setting."]},{"l":"Acceptance region","p":["Recall the the two conditions to solve a block. Preliminaries An equivalent formulation is to require that (X(h),Y(h)) must be an element of the acceptance region A_{\\tau}\\subset [0,1]^2 defined as","The target controls the difficulty, obviously if the target is decreased then it is more difficulty to mine a block."]},{"l":"More insight on the log scale","p":["If we apply the logarithmic transformation on the acceptance region A_{\\tau}, the condition","can be reformulated as","Recall that x and y are less than 1. This means -\\log(x) and -\\log(y) are positive. We can therefore visualize the acceptance region A_{\\tau} in the first quadrant of a Cartesian coordinate system representing -\\log(x) and -\\log(y) along its axes.","The following figure depicts the situation in log scale, the acceptance region A_{\\tau} is colored light blue:","Acceptance Region"]},{"i":"pushforward-measure-on-log-scale","l":"Pushforward measure on log scale.","p":["On the log scale we consider the transformed vector (-\\log(X),-\\log(Y)). The probability distribution of this transformed vector is the pushforward measure of (X,Y) through the map g: [0,1]^2 \\to \\mathbb{R}_{\\ge0}^2, (x,y)\\mapsto(-\\log(x),-\\log(y)). Note that by independence of X and Y","Since the Borel \\sigma-algebra on \\mathbb{R}_{\\ge 0}^2 is generated by the sets [0,x]\\times [0,y], x,y\\in\\mathbb{R}_{\\ge0} this proves that the pushforward measure is the product measure of two identical exponential distributions.","With this info we can do probability-theoretic calculations on the log scale."]}],[{"l":"Mining Probability","p":["Recall that a block is rejected if the Sha256t hash of its header is too small, i.e. if Y< c. Furthermore, the smaller Y the easier it is to satisfy the second condition XY^{0.7}< \\tau because larger, and therefore easier-to-mine Verushash v2.1 hashes are accepted.","Now consider a specific mining setting. We denote the Verushash v2.1 hashrate by \\mathfrak{h}_X and the Sha256t hashrate by \\mathfrak{h}_Y. For simplicity we will call \\mathfrak{h}_X the CPU hashrate and \\mathfrak{h}_Y the GPU hashrate because these are the devices that the respective algorithms are typically mined on at the moment. We will denote the \\frac{\\mathfrak{h}_Y}{\\mathfrak{h}_X} by a and since GPU hashrate is usually greater than CPU hashrate a will be greater than 1. We call this number the hashrate ratio.","To match CPU hashrate, hashes computed on GPU must be filtered, and from the discussion above a reasonable filter condition is to compute Verushash v2.1 on headers h that satisfy","This way we would select fraction 1/a of GPU hashes to check Verushash v2.1 on the corresponding headers. The fraction 1/a of GPU hashrate will exactly match the CPU hashrate such that filtered GPU results will come at the right rate to be processed by CPU.","Note that this is only true for a > (1-c)^{-1}, for the small range between 1 and (1-c)^{-1}(which is only a tiny bit larger than 1) the above reasoning would need to treat the case where filtering cannot avoid that some GPU hashes are rejected for Y being smaller than c if we want to match CPU rate. In this case CPU and GPU hash rates are just too close to allow enough filtering. But we ignore this small range for now as usually GPU hash rate on Sha256t is orders of magnitude larger than CPU hashrate on Verushash v2.1.","For some number d \\in [c,1] it holds that","We denote the conditional probability to mine a block for Y(h) filtered to be in the interval [c, c+1/a] by p_{\\tau}(a). If we plug in d=c+1/a above, we observe that"]}],[{"i":"janusscore---a-combined-hashrate-equivalent","l":"Janusscore - a combined hashrate equivalent","p":["We define the Janusscore S(\\mathfrak{h}_X,\\mathfrak{h}_Y) for Verushash v2.1 hashrate \\mathfrak{h}_X and Sha256t hashrate \\mathfrak{h}_Y by","With this definition we can express the expected number mined blocks with traget \\tau in time t as","This means two things:","For every target \\tau the expected number of mined blocks in time t is proportional to S(\\mathfrak{h}_X,\\mathfrak{h}_Y) and therefore S(\\mathfrak{h}_X,\\mathfrak{h}_Y) describes the mining efficiency.","S(\\mathfrak{h}_X,\\mathfrak{h}_Y) takes the role of a hashrate. For example one can estimate the Janusscore S by dividing the number of mined blocks by the time and the target (this can be used in pools to estimate the Janusscore based on number of shares, time and difficulty).","The Janusscore the unit \"hashes per second\" and can be interpreted as a hashrate equivalent to compare different setups.","Increasing one of the hashrates of \\mathfrak{h}_X, \\mathfrak{h}_Y while leaving the other constant will always increase the Janusscore."]},{"l":"Python code to compute the Janusscore"},{"l":"Julia code to compute the Janusscore"}],[{"l":"Hashrate Ratio","p":["The hashrate ratio is the quotient a of Sha256t hashrate \\mathfrak{h}_Y and Verushash v2.1 \\mathfrak{h}_X:"]},{"l":"Hashrate Ratio Boost","p":["The Janusscore satisfies","with","for a\\ge 1(again mind the small range [1,(1-c)^{-1}] where the reasoning is not correct). We therefore call \\gamma(a) the hashrate ratio boost for hashrate ratio a. It is a multiplicative factor applied to a hypothetical reference Janusscore S(\\mathfrak{h}_X,\\mathfrak{h}_X) to express S(\\mathfrak{h}_X,\\mathfrak{h}_Y). The function \\gamma looks like this:","Acceptance Region","There is a limit on the hashrate ratio boost:","where we used L'Hôpital's rule in the third step and finally plugged in the constant c = 0.005. This means that hashrate ratio boost cannot go above \\approx 15.35 no matter how much Sha256t hashrate is thrown into the game. The higher the hashrate ratio of GPU/CPU hashrates, the more CPU, i.e. Verushash v2.1 hashrate becomes the bottleneck.","This is intended and protects Warthog against ASICs applied to Sha256t. Such mining behavior will suffer heavily from being bottlenecked by CPU hashrate."]},{"l":"Julia code to plot this function"},{"l":"Estimating Hashrate Ratio from mined blocks","p":["The conditional density p_{Y,a} of Y given (X,Y)\\in A_{\\tau} and Y\\in [c,c+\\tfrac{1}{a}] is proportional to","for y\\in[c, c+\\frac{1}{a}]. Note that again this does not depend on the target \\tau. The conditional expectation is","If we have N blocks mined from a specific address we can consider their Sha256t hashes y_1,\\ldots,y_N to compute the empirical expectation (mean) \\bar{y}=N^{-1}\\sum\\limits_{i=1}^{N} y_i.","The method of moments can be used to get an estimate \\hat a of the hashrate ratio a from observed Sha256t average \\bar{y}. To do this we must find a such that the empirical expectation observed from the blocks and the conditional expectation match:","Unfortunately this can only be solved numerically, we cannot express the solution analytically. Since the hashrate ratio a is in the range [1,\\infty], the maximal conditional expectation is attained for a=1, if we observe an empirical mean \\bar y larger than this number","we just estimate \\hat a=1, otherwise we solve the above equation numerically. In the following code we cap estimation at factor 100000:"]},{"l":"Python code to estimate hashrate ratio"}],[{"l":"Compiling Warthog from source on Linux","p":["Compiling Warthog from soure is an alternative to the use precompiled binaries."]},{"l":"Installing required packages","p":["Before we can start make sure you have a recent Linux distribution. In this guide we are using Ubuntu 22.04.3 LTS. We need to update our package manager and install git, build-essential, meson and ninja-build:"]},{"l":"Cloning the Repo","p":["Now that we have git we can clone the Warthog repository from GitHub:"]},{"l":"Compiling","p":["A new directory should be created, let's cd into it and run meson build to create a build directory named build:","When you run the meson build command for the first time some extra dependencies will be downloaded so it might take a while. Now we have a build directory within the Warthog directory so we cd into it and start compilation with ninja:","Congratulations! You now have compiled the Warthog C++ source. But wait - there is a problem: we did not enable compiler optimizations. In meson compiler optimizations need to be explicitly enabled with the --buildtype=release flag. Then the compiled executables and libraries will be more efficient. This is important for mining because you will get better hashrate with optimized compilation.","So let's do this again, we will go up one directory and delete the build directory again. Then we recreate it but this time with the --buildtype=release option and compile again with ninja:","Note that now meson reports it has set buildtype: release.","After compilation finished successfully we can have a look at the compiled artifacts: Warthog currently compiles a node and a wallet. They are generated in the src directory within the build directory. Since the algo update miner is no longer in this main repo, you can see the available miner here. Have a look:"]}],[{"l":"How to start a Warthog node as a systemd service","p":["NOTE: This is only supported in Linux distros that use systemctl(Debian, Ubuntu, Mint etc.).","Enable auto restart when logged off (only need to do this once per machine): $ sudo loginctl enable-linger $USER","Create the directory structure: $ mkdir -p ~/.config/systemd/$USER","Create a file with the following content at that directory, file path: ~/.config/systemd/$USER/warthog.service","Reload systemctl daemon: systemctl --user daemon-reload","Enable auto restart for Warthog service: systemctl --user enable warthog","Start for Warthog service: systemctl --user start warthog","Check status for Warthog service: systemctl --user status warthog"]},{"l":"How to start a public node","p":["You need to have a static IP. Do as above but append the --enable-public flag at startup, i.e. use this file content:"]}],[{"i":"howto-run-a-warthog-node-with-docker","l":"HOWTO Run a warthog node with docker."},{"l":"Basic way"},{"l":"Modify your node","p":["Exemple you can add this type of arguments to run a node with stratum enabled"]},{"i":"run-a-rpc-public-node","l":"Run a (RPC) public node","p":["We advise you not to use the latest image, but rather to choose a stable version (latest release), currently zzjulien/warthog_node:0.4.24","Warthog image is whitelisted on runonFlux"]}],[{"l":"OpenCL Installation","p":["To mine on your GPUs you need to install GPU drivers with OpenCL support.","You can check whether your GPU has a working OpenCL support with the clinfo command. Install this program with","Then start it by typing","In our case we don't have any GPU drivers installed that support OpenCL:","The installation procedure depends on your GPU vendor."]},{"l":"AMD GPUs","p":["Our GPU is an AMD Radeon RX 5600 XT but clinfo does not detect any OpenCL installation for it yet. Visit the AMD support site https://www.amd.com/en/support and select the GPU model:","Then we need to install the downloaded deb package.","This will command will take a while downloading and installing more than 2GB worth of packages.","Now try clinfo agian:","The AMD OpenCL platform is now detected but there are no devices. This is because you need to add your user to the render group:","Now reboot your system. If you try clinfo again you now see the GPU device:"]},{"l":"NVIDIA GPUs","p":["First download your driver from https://www.nvidia.de/Download/index.aspx?lang=en-us by selecting your GPU model and clicking on \"Aggree Download\".","The downloaded file is a sh script and we need to make it executable. So we navigate to the Downloads directory and execute","Of course you need to insert your exact filename here. When we try to run it via","we get this error:","This means we need to execute the script no a lower run level without an X server running. In addition we must blacklist the default nouvaeu driver with this command:","Now reboot your system. Once rebooted you should switch to a lower run level. To do this press the three keys CTRL + ALT + F3 at the same time. You should see a black screen with login prompt like this:","Log in with your user name and password and then switch to a lower run level with","You can now start the installation as above, navigate to the Downloads directory and start the installation:","You should see these screens, just select \"Confirm installation\", then \"Yes\", \"Yes\", \"OK\".","Now that the NVIDIA driver installation is complete restart your system again you should be able to see your device in the clinfo command:"]}],[{"l":"Pool Integration"},{"l":"Share validation","p":["I have written a C++ backend which support computes the hash product","Verushash(header)* Sha256t(header)^ 0.7","This is a number between 0 and 1. If the first condition","Sha256t(header) > c for some hard-coded constant c.","is not met it returns 1. This is a convenient way for pools to check valid shares: Instead of using the block real target, the pool would set an easier difficulty in Stratum jobs, which corresponds to a larger target t^* than the block target t. A share is valid if the hash product returned by the backend is smaller than t^*. If the returned value is 1 as is done by the backend if the first condition above is not met, the share is automatically invalid because t^* will be between 0 and 1.","The pool backend has two endpoints:","/score/:headerhex: It computes the score above (hash product). For performance the score is not embedded into json encoded but directly returned. On error an empty string is returned. headerhex is the hex encoded header (80 bytes = 160 bytes hex encoded).","/target_to_double/:targethex: It converts the block target from byte representation to double. This is important to check if the score actually solves a block."]},{"l":"Block structure","p":["Each block consists of a 10 extranonce bytes followed by 3 sections:"]},{"i":"1-new--address-section-2n120-bytes","l":"1. New address section (2+n1*20 bytes)","p":["This section starts by encoding the number n1 of new addresses registered in this block, then n1 elements of 20 bytes each follow."]},{"i":"2-reward-section-16-bytes","l":"2. Reward section (16 bytes)","p":["This section encodes the mining reward (miner + amount)."]},{"i":"3-transfer-section-4n399-bytes","l":"3. Transfer section (4+n3*99 bytes)","p":["It starts by encoding the number n3 of transfers in a 4 byte network byte order integer. Then follow n3 entries of 99 bytes each, one for each transfer. If n3 is 0 then the transfer section is omitted completely, in this case it is 0 bytes long. Miner devs can detect this by comparing the current cursor with the end of the block byte vector when parsing the sections of a block."]},{"l":"Merkle Root Computation","p":["Merkle tree has the n1 + 1 + n3 elements of the three sections as its leaves: n1 20 byte elements, one 16 byte element and n3 99 byte elements. The Merkle tree uses sha256 to combine two elements into one in each hierarchy level.","Merkle root is computed this way:","In the last step we append the 10 byte extranonce space from the beginning of the block to the hashed data for the final hash. The data we append these 10 extranonce to we call merklePrefix. The Merkle root is therefore sha256(merklePrefix + extranonceBytes). The merklePrefix is transmitted in the Stratum protocol. It is either 32 bytes or 64 bytes long. Only if you have 1 leaf in the Merkle tree, the Merkle prefix will be 32 bytes, otherwise the Merkle prefix will be the two children of the root concatenated."]},{"l":"Scanning the Chain","p":["Pool Integration"]},{"l":"Pool Payout","p":["Pool Integration"]},{"l":"Miners for Testing","p":["Pool Integration"]}],[{"l":"Stratum Protocol","p":["Messages are newline (\\n) terminated json strings sent over plain TCP with optional TLS encryption. URI scheme is stratum+tcp for plain TCP and stratum+ssl or stratum+tls if TLS encryption is used (for some reason \" ssl\" is more prevalent than \" tls\" as URI scheme despite in fact TLS is actually used)."]},{"l":"Establishing a stratum connection","p":["After establishing a TCP connection (and optionally TLS) the first message is sent from the Client and must be of type mining.subscribe:"]},{"i":"miningsubscribe","l":"Mining.subscribe"},{"i":"request-from-client","l":"Request from client:"},{"i":"response-from-pool","l":"Response from pool:"},{"l":"Mining authorize","p":["The next message is again send from the client and must have method field equal to mining.authorize:"]},{"i":"request-from-client-1","l":"Request from client:"},{"i":"response-from-pool-1","l":"Response from pool:","p":["Now the connection is established. The pool n"]},{"l":"Events pushed from pool server to clients","p":["There are two kind of events that sent from the pool: mining.notify and mining.set_difficulty."]},{"i":"miningnotify","l":"Mining.notify"},{"i":"notable-differences-from-bitcoins-stratum-protocol","l":"Notable differences from Bitcoin's Stratum protocol:","p":["This method has only 7 parameters instead of 9 parameters in Bitcoin's stratum protocol. Bitcoin's stratum protocol's third (coinbase 1) and fourth (coinbase 2) parameters are not necessary in Warthog. Furthermore instead of Bitcoin's Merkle branches parameter we have a Merkle prefix parameter. Merkle root is computed as follows:"]},{"l":"Merkle root computation","p":["Merkle root is sha256(merklePrefix + extranonce1 + extranonce2). Miners can choose extranonce2 arbitrarily (with length specified by pool) to generate different Merkle roots."]},{"l":"Header structure","p":["The parameters sent in a mining.notify event and a 4-byte nonce selected by the miner can be used to form a header to be hashed by the miner as follows:","Bytes","Meaning","1-32","prevHash","33-36","nbits","37-68","Merkle root (controlled by miner, see above)","69-72","version","73-76","ntime","77-80","nonce (chosen by miner)"]},{"i":"miningset_difficulty","l":"Mining.set_difficulty"},{"i":"notable-differences-from-bitcoins-stratum-protocol-1","l":"Notable differences from Bitcoin's Stratum protocol","p":["In contrast to Bitcoin's stratum protocol the target is just the inverse of the difficulty. In Bitcoin there is an additional factor of 2^ 32 involved for historical reasons. Since Warthog was written from scratch, it not carry this historical burden. This means the miner must meet the target 1/difficulty to mine a share."]},{"l":"Events pushed from miner to pool"},{"i":"miningsubmit","l":"Mining.submit","p":["When the miner has found nonce and extranonce2 such that the block is","Pool will reply with","or report error."]},{"l":"Error reporting","p":["Pool response must specify request id in the id field. Errors are reported by setting result to null and specifying error details in an array of size 3 (code, message, additional info) in the error field.","01/21/2024 6:07 PM Every coin has its own stratum specification and I changed just very little. Basically we do not have coinbases but mining.notify looks like this:"]}],[{"l":"Miner Integration"},{"l":"Condition to Mine a Block","p":["Miner Integration"]},{"l":"Mining Strategy","p":["Miner Integration"]},{"l":"Stratum Protocol","p":["Miner Integration"]},{"l":"Reporting Hashrate","p":["Miners should report Sha256t and Verushash v2.1 measured hashrates and in addition to that they should report the Janusscore. Janusscore describes the mining efficiency (combined hashrate) and can be computed from sha256t and verushash hashrate variables as follows:","Miner Integration"]},{"l":"Pools for testing","p":["Miner Integration"]}],[{"l":"Wallet integration","p":["In this guide we demonstrate how to handle wallets and send transactions in Python 3, NodeJS and Elixir."]},{"l":"Prerequisites","p":["We use the pycryptodome and pycoin Python packages.","We use the elliptic, node:crypto, sync-request and secp256k1 NodeJS packages.","We use the {:curvy, ~ 0.3.1}, {:jason, ~ 1.4} and {:httpoison, ~ 2.0} Hex packages."]},{"l":"Handling wallets","p":["Below we demonstrate how to","generate a new private key,","load a private key from hexadecimal encoding,","derive a public key from a private key,","derive a raw Warthog address form a public key and","extend the raw Warthog address by its checksum to obtain an ordinary Warthog address."]},{"i":"generating-signing-and-sending-a-transfer-transaction","l":"Generating, signing and sending a transfer transaction","p":["In Warthog transactions are pinned to a specific block the blockchain. The height of this block is its pinHeight, its hash the pinHash. This information has to be retrieved from the node in order to start generating a transaction, a transaction with a pinHeight that is too old be discarded. This serves two purposes","Users can be sure that transactions will not be pending forever.","By choosing a particular pinHeight users can actively control the time to live (TTL) of a pending transaction before it is discarded.","Not all height values are valid pinHeights, instead they must be a multiple of 32. For convenience the /chain/head endpoint provides the latest pinHeight value together with the corresponding block hash pinHash. In our code sample below we will use this endpoint.","In addition we demonstrate how to create the bytes to sign, how a valid sekp256k1 recoverable signature in custom format is generated and how to send the transaction to the Warthog node via a HTTP POST request. For reference read the API guide. The below code uses the private key pk variable from the above code snippet.","Javascript does not support 64 bit integers natively, one has to resort to BigInt, which does not serialize as a JSON number required by the API. Therefore we are just serializing a normal Javascript number which will only be accurate up to 15 digits, i.e. only 7 figure WART amounts can be precisely handled this way because Warthog has a precision of 8 digits after comma. The total hard cap of WART is 18m which is a 8 figure number, so practically the 7 figures should be sufficient for most purposes."]}],[{"l":"API"},{"l":"Configuration","p":["API is accessed via the RPC endpoints of the node. The endpoints socket can be configured via the --rpc command line option:","For example invoke","to start the node with RPC listening on all devices on port 3000.","The RPC endpoint should not exposed to the internet, use appropriate firewall settings.","Below we assume the RPC socket is accessible at localhost:3000. On startup the node reports the RPC endpoint setting:"]},{"l":"Endpoint Overview","p":["/account/:account/balance","/account/:account/history/:beforeTxIndex","/chain/append","/chain/block/:id","/chain/block/:id/hash","/chain/block/:id/header","/chain/grid","/chain/hashrate/:windows","/chain/hashrate/chart/:from/:to/:window","/chain/head","/chain/mine/:address","/chain/signed_snapshot","/chain/txcache","/peers/banned","/peers/connect_timers","/peers/connected","/peers/endpoints","/peers/ip_count","/peers/offenses/:page","/peers/unban","/tools/encode16bit/from_e8/:feeE8","/tools/encode16bit/from_string/:feestring","/tools/janushash_number/:headerhex","/tools/wallet/from_privkey/:privkey","/tools/wallet/new","/transaction/add","/transaction/lookup/:txid","/transaction/mempool","/ws/chain_delta","Append mined block","Create a new wallet","DESCRIPTION","Generate data required for mining","GET","Get chain delta events","METHOD","PATH","POST","Restore wallet from a private key","Round coin amount string to closest 16 bit representation (for fee specification)","Round raw 64 integer to closest 16 bit representation (for fee specification)","Send transactions","Show balance of specific account","Show banned peers","Show chain snapshot","Show content of mempool","Show current hashrate based on latest n blocks","Show hash of specific block","Show header and body of specific block","Show header grid (used for sync)","Show header of specific block","Show info of connected peers","Show info on chain head","Show known peer endpoints","Show number interpretation of a header's janushash","Show offenses of peers","Show peer IPs","Show timers used for reconnect","Show transaction cache","Show transaction history of specific account","Transaction lookup","Unban all peers","WEBSOCKET","You can see an HTML overview of all supported RPC endpoints by opening localhost:3000 in your browser. Currently the following endpoints are supported:"]},{"l":"Detailed Description"},{"i":"post-transactionadd","l":"POST /transaction/add","p":["amount (optional)","Amount of coins to send multiplied by 10^ 8. For example to send one coin this value must be 100000000.","Amount of coins to send. Format must be string, non-scientific notation with at most 8 digits after comma. \"1\" or \"1.00000000\" are valid.","Amount of coins to spend on transaction fees multiplied by 10^ 8. For example to send one 0.00000001 coins this value must be 1. This value must be exactly representable value in a 16 bit encoding, see below.","Amount of coins to spend on transaction fees. This value must be exactly representable value in a 16 bit encoding, see below.","amountE8 (optional)","DETAILS","fee (optional)","feeE8 (optional)","hex-encoded 65 byte compact recoverable ECDSA signature in custom format, see below.","Miner fee must be exactly representable in a 16 bit encoding.","nonceId","NOTE:","PARAMETER","pinHeight","Send transactions in JSON format:","Signature includes block hash at this height","signature65","string","string of length 130","string of length 48","The address that coins shall be transferred to","The transaction fee must be specified either via fee or via feeE8.","The transfer amount must be specified either via amount or via amountE8.","To avoid double spend, there can only be one transaction with a specific (pinHeight,nonceId) pair. The same nonceId can be used for different pinHeight values","toAddr","TYPE","unsigned 32 bit integer","unsigned 64 bit integer"]},{"l":"Details on fees","p":["Fees are not subtracted from the amount sent in the transaction. The sender spends both, transfer amount and transaction fee, toAddr receives the transferred amount and the miner of the block including this transaction gets the transaction fee.","For efficiency and compactness transaction fees are internally encoded as 2-byte floating-point numbers (16 bits), where the first 6 bits encode the exponent and the remaining 10 bits encode a 11 bit mantissa starting with an implicit 1. Of course not every 64 bit value can be encoded in 16 bits and only fee 64 bit values which are representable exactly in the 16 bits encoding are accepted. You can use the /tools/encode16bit/from_e8/:feeE8 or /tools/encode16bit/from_string/:feestring endpoints to round an arbitrary 64-bit fee value to an accepted 64 bit value."]},{"i":"how-to-specify-the-sender","l":"How to specify the sender?","p":["The sender's address is recovered from the recoverable ECDSA signature signature65. It is implicitly specified by creating a signature with the corresponding private key."]},{"l":"Signature generation","p":["1 -32","33-36","33-64","37-40","41-43","44-51","52-71","65","72-79","amountE8( uint64_t in network byte order)","BYTES","Call the /chain/head endpoint and extract the pinHash and pinHeight fields.","Compute transaction hash. The transaction hash is the SHA256 hash of the following bytes:","Concatenate the parameters to form the 65-byte compact normalized (lower s) recoverable signature with the following byte structure:","DESCRIPTION","feeE8( uint64_t in network byte order)","Generate the secp256k1-ECDSA recoverable signature of the 32-byte transaction hash using the private key corresponding to the sender's address. The signature will have three properties:","nonceId( uint32_t in network byte order)","Note that this is not the standard compact recoverable signature representation because in Warthog, the recoverable id is the last byte of the 65 byte signature and has no offset of 27.","pinHash(hash of block at height pinHeight)","pinHeight( uint32_t in network byte order)","r","r: 32 byte coordinate parameter","recid","recid: 1 byte recovery id, it should automatically have one of the four values 0,1,2,3.","reserved(3 bytes containing 0)","s","s: 32 byte coordinate parameter","The following steps are required:","toAddr receiving address (20 bytes without the final 4 byte checksum)"]},{"l":"Integration guides","p":["We provide working code snippets on how to generate and send transactions in Python3, Elixir and NodeJS."]},{"i":"post-transactionadd-1","l":"POST /transaction/add","p":["Send transactions in JSON format, returns transaction hash in hex format:"]},{"i":"get-transactionmempool","l":"GET /transaction/mempool","p":["Show content of mempool. Example output:"]},{"i":"get-transactionlookuptxid","l":"GET /transaction/lookup/:txid","p":["Transaction lookup by transaction id. Example output of /transaction/lookup/4b3bc48295742b71ff7c3b98ede5b652fafd16c67f0d2db6226e936a1cdbf0a5:"]},{"i":"get-chainhead","l":"GET /chain/head","p":["Show info on chain head. Example output:"]},{"i":"get-chaingrid","l":"GET /chain/grid","p":["Show hexadecimal header grid. This grid is used for chain sync to allow nodes spot points where chains diverge. Example output (truncated):"]},{"i":"get-chainsigned_snapshot","l":"GET /chain/signed_snapshot","p":["Show chain snapshot. Example output"]},{"i":"get-chainblockidhash","l":"GET /chain/block/:id/hash","p":["Show hash of specific block. Example output of /chain/block/366700/hash"]},{"i":"get-chainblockidheader","l":"GET /chain/block/:id/header","p":["Show header of specific block.","Example output of /chain/block/366700/header"]},{"i":"getchainblockid","l":"GET/chain/block/:id","p":["Show header and body of specific block. Example output of /chain/block/366700"]},{"i":"get-chainmineaddress","l":"GET /chain/mine/:address","p":["Generate data required for mining. Example output of /chain/mine/11c6c0f7148a845cc899360a38fa839ba3d5e719293bb5c6"]},{"i":"get-chainhashratewindow","l":"GET /chain/hashrate/:window","p":["Show current hashrate based on latest n blocks","Example output of /chain/hashrate/100"]},{"i":"post-chainappend","l":"POST /chain/append","p":["Append mined block. Miners must POST mined block they received from GET /chain/mine/:address. TODO: Detailed description"]},{"i":"get-accountaccountbalance","l":"GET /account/:account/balance","p":["Show balance of specific account. Example output:"]},{"i":"get-accountaccounthistorybeforetxindex","l":"GET /account/:account/history/:beforeTxIndex","p":["Show transaction history of specific account Example output:"]},{"i":"get-toolsencode16bitfrom_e8feee8","l":"GET /tools/encode16bit/from_e8/:feeE8","p":["Round raw fee integer representation (coin amount is this number divided by 10^ 8) to closest 16 bit representation. This is required for fee specification in the /transaction/add endpoint. Example output of /tools/encode16bit/from_e8/5002"]},{"i":"get-toolsencode16bitfrom_stringfeestring","l":"GET /tools/encode16bit/from_string/:feestring","p":["Round fee amount string to closest 16 bit representation. This is required for fee specification in the /transaction/add endpoint. Example output of /tools/encode16bit/from_string/0.001:"]},{"i":"get-toolsjanushash_numberheaderhex","l":"GET /tools/janushash_number/:headerhex","p":["Show number interpretation of a header's janushash. Header is specified in hexadecimal encoding.","Example output of /tools/janushash_number/some 160 character hex string:","We do not use JSON encoding in this endpiont for performance reasons to support use of this endpoint by pool share validation. If the input :headerhex cannot be parsed, the result is an empty string."]},{"i":"get-toolswalletnew","l":"GET /tools/wallet/new","p":["Create a new wallet.","Example output of /tools/wallet/new:","This endpoint should only be used for testing purposes. For security reasons the node should not be involved in wallet-related operations involving a private key."]},{"i":"get-toolswalletfrom_privkeyprivkey","l":"GET /tools/wallet/from_privkey/:privkey","p":["Restore wallet from a private key.","Example output of /tools/wallet/from_privkey/d3ce2210adf0fccabe31b61309e2b80c029a7e4e305aeed29432edd428d35c3d:","This endpoint should only be used for testing purposes. For security reasons the node should not be involved in wallet-related operations involving a private key."]},{"i":"websocket-wschain_delta","l":"WEBSOCKET /ws/chain_delta","p":["Get chain delta events. There are 2 types of events:","blockAppend: The data object is as returned by /chain/block/:id.","rollback: The data object is {length: length} specifying chain length after rollback.","Example:","Example output :"]}],[{"l":"Roadmap"},{"i":"q2---full-nodes-in-web-browsers","l":"Q2 - Full nodes in web browsers","p":["Warthog is an experimental cryptocurrency where we try to push the boundaries of what is possible in crypto. After having successfully implemented the world's first Proof of Balanced Work mining algorithm we try to port full nodes to the web browser. This has several advantages:","Full nodes can be easily spawned on a smartphone just by loading a website.","This lowers the entry-barrier for new users.","The stability of the network benefits from more nodes.","In connection with the light-weight DeFi, ease-of-use on smartphones will be of particular interest.","As of now, to the best of our knowledge there is no other cryptocurrency supporting in-browser full nodes. This may be due to the fact that the technological foundations needed to persist a blockchain in the web browser were only recently developed."]},{"l":"Persisting the Blockchain","p":["The fact that Warthog relies on SQLite to persist state makes it possible to store the database in the Origin Private File System using WasmFS. The technology is very new:","Emscripten's WasmFS is \"Current Status: Work in Progress\".","Origin Private File System was only supported since recently by major browsers.","Support of SQLite for WasmFS was only recently added in version 0.3.43.","Current browsers allow to store persistent data (OPFS) in the 3-digit gigabyte range when there is enough disk space available. This is sufficient for blockchain applications."]},{"l":"Communication between nodes","p":["Since raw TCP connections are not supported in web browsers, communication can only be implemented over websocket and WebRTC.","In a first step nodes need to be equipped with websocket communication capabilities. Since browsers cannot act as websocket servers, in-browser nodes will first act as leechers, i.e. they will only connect to public nodes but cannot accept inbound connections.","Inbound connections could be realized via WebRTC. Later WebRTC might be added to allow nodes accept inbound connections from other in-browser nodes."]},{"l":"Road to in-browser nodes","p":["Rewrite node communication code in an abstract way (using C++'s virtual methods)","Add Websocket communication capability to nodes. This requires adding websocket server to listen for incoming websocket connections.","Make code modifications to compile node's code using Emscripten. This requires conditionally disabling TCP network libraries and also Websocket server support for webassembly target and conditionally using libraries supporting browser's built-in websocket support.","Figure out a way to extract relevant code from SQLite's Wasm extension which is actually a Javascript library. This requires","Dissecting the extension's code and throwing away all Javascript code to distill the essential things to implant into Warthog codebase.","Retrieving relevant compilation flags from the Makefiles.","Testing everything with the C++ wrapper for sqlite.","Find a way to disallow concurrent access to the database from multiple instances in different tabs. Two nodes should not run against the same database.","Mess around with Emscripten peculiarities and additionally required compilation flags (-sPROXY_TO_PTHREAD, allow dynamic memory growth, allow shared memories between threads, enabling C++ exceptions etc.).","Mess around with browser security (for example special HTTP headers COOP+COEP are required to be sent to support SharedArrayBuffer)."]}],[{"l":"Version History","p":["v0.4.0: fix mempool bug","v0.4.1-2: increase max transactions mined into blocks + mempool sorted by fee","v0.4.10 : fix reward section of the block generation","v0.4.11 : Rework of the block generation (blank when there is 0 transfers)","v0.4.12 : Modification of the API to allow you to modify the number of blocks on which you want a hashrate hestimation.","v0.4.13 : Fix the json key for the previously added API method","v0.4.14 : Add wallet tools in API endpoint","v0.4.15 : disable transactions as fallback","v0.4.16 : Finish the websocket endpoint","v0.4.17 : Add markle prefix in an endpoint","v0.4.18 : Add additional info in an endpoint + more error code","v0.4.19 : Fix of a solo stratum bug","v0.4.20 : delete cached stratum block when chain advances","v0.4.21 : Disable mine/ endpoint for old structure block.","v0.4.22 : New endpoint for pool development","v0.4.24(last stable version): Add Synced field for two endpoint ()","v0.4.25 : Core developers have started working on the network part","v0.4.5: Solo Stratum pool integrated into node, use --stratum=0.0.0.0:3456 to enable on port 3456","v0.4.6 : enable macos build","v0.4.7 : fix an bug in blog generation","v0.4.8 : rework of transaction propagation","v0.4.9 : fix transfer count in the block generation part of the code + disable interactive mode of the wallet when all parameters are given"]}],[{"l":"Wart Dapp","p":["Address Book","And at the moment the last tab is Release Notes, where all the changes for each version of the application are summarized.","At the very beginning, you are taken to the window for selecting a connection method. If you don’t want to, don’t know how, or for some other reason don’t have your own node running, then click on ‘Connect public node’ and the application will automatically connect to the public node.If you want to use a connection to your own node, enter the node’s IP address and port.","Connect public node","Download here.","Miners Chain","Next is the Address Book tab, here you can save addresses that are important to you and assign names or titles to them, after which you can conveniently use them at any time","Next is the Miners Chain tab, the principle of operation is the same as the Transactions Chain tab, only as a result you will receive the addresses of all the miners who mined blocks in the interval of your choice and opposite each address the number of coins mined by them in the interval of blocks you selected.","Overview","Release Notes","Send","Tab for creating transactions.","The first tab displays the address of the wallet currently selected for operation. Address","The next is the wallet selection window, you can create a new wallet, import by mnemonic phrase or private key, after which the wallet will be saved and visible in the field below (when you log in again, you need to select the address you want to work with at the moment and enter the password)","The next tab is Chain Transactions, here in the “blocks” field you need to enter the number of blocks for which you want to see all the transactions of the network, for example: If you enter, for example, 300 blocks, then with the current height of 999400 blocks we will get 999400-300 =999100, that is, you will see all transactions on the network for the period from block 999100 to the current 999400","The next window is the main menu of the application; each function will be described below.","Transactions Chain","Wallet Selection"]}],[{"i":"warthog---an-experimental-fresh-rewrite-of-a-pow-cryptocurrency","l":"Warthog - An experimental fresh rewrite of a PoW cryptocurrency","p":["This white paper is a work in progress."]},{"l":"Introduction and Project goals","p":["Warthog is a classical Proof-of-Work (PoW) based cryptocurrency which is meant to be a fun and experimental side project of its developers Pumbaa, Timon and Rafiki who work in blockchain industry.","We are working on Warthog in our free time and there is always the risk that we leave due to time constraints or personal reasons. In fact our colleague Timon has already left the team. Therefore we are trying to build up a strong community backing the project.","Mainly one can describe this project as an experiment to try out new things and learn how blockchain technology works in detail. But at the same time we want to be as transparent and fair as possible and avoid as much as possible fishy and questionable practice currently seen in most other new projects.","The code is freshly written in C++ 20 and is not a cheap fork of any other project. Therefore there is a risk of bugs but at the same time real effort is put into this project which sets it apart from most competitors.","The community is welcome to take actively part in the evolution of Warthog, the logo and the explorer are made by volunteers and also possible choices for a mining algorithm are proposed. The connection with the community shall be preserved and extended in the future. If you want to join, please do so!","There is no specific purpose or use case of Warthog. However we want to revive the days when crypto was a fun and an interesting experimental thing. One of our experiments with this project is to use SQLite to store blocks and state. Another is the completely novel idea of syncing nodes via chain descriptors instead of asking other nodes for blocks by their hashes.","One design principle of Warthog is fast sync speed and a low impact on system resources which is achieved by the use of fast hashing algorithms, appropriate data structures and our custom-built sync algorithm.","For now and in the near future the primary plan is to make the node implementation more robust and improve infrastructure like explorer and API for better interoperability."]},{"l":"Technical Details"},{"l":"Retarget Logic","p":["Similarly to Bitcoin, the warthog blockchain will scale its difficulty periodically to adjust for changing hashrate. Changes in difficulty is partitioned into two phases:","In the initial phase the difficulty is adjusted every 720 blocks which corresponds to approximately 4 hours.","In the second phase the difficulty is adjusted every 8640 blocks which corresponds to 2 days.","The reason for this two-phase approach is the high variability of hashrate in early stages of a project's life which initially requires a more frequent difficulty adjustment. On the other hand too short intervals also have disadvantages such as the tendency to oscillate and a possibly higher impact of faked timestamps. Therefore the second phase stretches the difficulty adjustment interval after the initial phase.","While in Bitcoin the difficulty change is capped by factor 4, we have implemented a factor 2 cap because our difficulty adjustment is more frequent than 2 weeks."]},{"l":"Emission Scheme","p":["% of total supply in circulation","~ June 29 2024","~ June 29 2025","~ June 29 2026","~ June 29 2027","0 years","0%","1 years","2 years","25%","3 years","4 years","50%","62.5%","75%","Before halving occurs every block yields 3 WART as miner reward. Since the block time is 20 seconds, every day approximately 60/20 * 60 * 24 = 4320 blocks and 12960 WART are mined before halving.","Date","June 29 2023","Lifetime","There is no tail emission which means there is a hard cap of the amount in circulation. The hard cap is 18921599.68464 WART (around 19 million coins).","Warthog was started without any premined or reserved amount of coins on June 29, 2023. The project implements a classical halving-based emission scheme with halvings occurring every 3153600 blocks (every 2 years). The emission for the next 4 years is summarized in the following table:"]},{"l":"Coin Precision","p":["The reference implementation uses the C++ data type uint64_t for storing amounts of WART. This is a 64 bit unsigned integer. To represent fractions of a coin these values are interpreted in fixed point arithmetic with 8 digits precision. This means that 1 WART is internally represented as uint64_t number with value 100000000. The smallest representable step is 0.00000001 WART and represented as uint64_t number with value 1.","For easier integration all API endpoints return both, the WART amount as a string (like amount: 12.0), and the internal integer representation indicated with label \" E8\" (like amountE8: 1200000000)."]},{"l":"One-of-a-kind chain descriptor based sync","p":["This project is an experiment where the developers try out new things and push the boundary of what is possible in blockchain technology. We invented a completely unique and new way of syncing nodes which is not presently not known to the industry.","Traditionally during synchronization new nodes request block bodies identified by block hashes. The replying node has to look up the block body based on the hash and then sends it back.","In contrast we have invented a node communication protocol which works without block hashes for block body lookup. In our setup nodes keep track on fork heights with other nodes. A chain descriptor is used to identify a specific chain on the peer. When a node appends to its chain, the chain descriptor remains unchanged, however the current chain descriptor is increased when the consensus chain switches to a longer fork. Block bodies for previous chains are also kept for some time in case a peer requests them.","When syncing nodes request block bodies identified by a chain descriptor and a block range. This way we avoid overhead in communication and lookup."]},{"l":"SQLite backed block store","p":["SQLite is a battle-proven and well-established embedded SQL database engine. Warthog nodes use SQLite as their main storage engine for both, blocks and state. Nodes also index transactions and can provide basic blockchain explorer functionality directly via API thanks to SQLite.","SQLite databases are also portable across 32-bit and 64-bit machines and between big-endian and little-endian architectures such that chain snapshots can easily shared. Furthermore SQLite supports transactions which are essential for data integrity even in case of a power outage or node crash.","The default SQLite database file name used for the chain is chain.db3 and can be configured via the --chain-db command line option"]},{"l":"Account based architecture","p":["Warthog implements an account based architecture. This is similar to Ethereum and different from Bitcoin's UTXO model. Every account along with its balance is stored in the State table of the chain database. For efficiency reasons accounts are referred by their id: Every account is assigned a unique auto-incremented id value on first use. This makes blocks more space-efficient since a block id only requires 8 bytes of storage whereas an address would require 20 bytes."]},{"l":"Anatomy of a block","p":["The binary content of a block is a concatenation of the following sections in their specified order:","Mining section","New address section","Reward section","Transfer section","Below we describe the above sections. All numbers and id values are in network byte order."]},{"l":"Mining section","p":["This section allows miners to put 4 bytes of arbitrary data to affect the merkle hash.","byte range","content","1-4","arbitrary data"]},{"l":"New address section","p":["This section lists new addresses that receive payments in this block and therefore need to be added to the state table. This way they will be assigned a new id value which is referenced in the other sections to specify a particular account.","byte range","content","1-4","number n of new addresses","5-(4+n*20)","n addressess of 20 bytes each","Miners are responsible to ensure that the addresses appearing in the new address section are not already present in the state table and are actually referenced in this block. Otherwise the block is considered invalid."]},{"l":"Reward section","p":["Mining reward is distributed to at least one reward address.","byte range","content","1-2","number r of reward entry","3-(4+r*16)","r reward entries","Every reward entry consists of 16 bytes:","1-8","accountId","9-16","amount","The sum of the amounts received by the addresses listed in the mining reward section must not exceed the total mining reward (block reward + transaction fees), otherwise the block is considered invalid.","The total size of the mining section is 2+ r*16 bytes."]},{"l":"Transfer section","p":["1-4","1-8","17-18","19-26","27-34","35-99","5-(4+t*99)","9-16","amount","byte range","content","Each payment entry has length 99 bytes. Compare this to the average transaction size of around 200 bytes per Bitcoin transfer.","Every transfer entry has the following structure:","fee","fromAccountId","number t of transfer entries","pinNonce","recoverable signature (65 bytes)","t transfer entries","The transfer section contains the transfers made in this block. Its binary outline is as follows:","toAccountId"]},{"l":"Fee specification","p":["For efficiency and compactness transaction fees are encoded as 2-byte floating-point numbers (16 bits), where the first 6 bits encode the exponent and the remaining 10 bits encode a 11 bit mantissa starting with an implicit 1. This means that fee values cannot be 0 and are of lower precision than regular amount values which use 4 bytes. A fee of value of 0 specified on transaction generation will automatically transform into the minimal fee value of 0.0000001 WART."]},{"l":"Project Links","p":["Bitcointalk","GitHub","Discord","Website","Explorer"]}]]