[[{"l":"Welcome","p":["Warthog is an experimental L1-cryptocurrency implementation without specific focus. Don't take this project seriously, it is just our hobby experiment. This project is not a dumb fork of something else. It was developed completely from scratch!","Warthog's Janushash mining algorithm is unique across the crypto space, it is the world's first Proof of Balanced Work (PoBW) algorithm, which requires CPU and GPU hash power for mining.","The core repository offers two applications:","Node","Command line Wallet","Furthermore there are two third-party wallets:","wart-wallet(open source)","Warthog-network-dapp(open source)","You can join the Warthog community on Discord."]},{"l":"Starting a node","p":["Download the latest version from here.","The node does not have external dependencies, it can be started via command line:","The node starts syncing. The node needs to be running and synced while we are using the wallet and miner."]},{"l":"Using the CLI Wallet","p":["We explain how to use the command line wallet. If you don't know how to use the command line, you should use a graphical wallet such as wart-wallet or Warthog-network-dapp.","Let's create a new wallet","A new wallet called wallet.json file is created. It is not encrypted and other malicious programs you run on your computer can steal it. Back it up. Don't show it to anyone. The private key can be used to restore the wallet. To print your address use the command","To check your balance use","You can send some coins with","The wallet asks for the address you want to send to, the fee and the amount. You can type in values like these: Then confirm with \"y\" and press enter. Of course you cannot send because your wallet address has no coins yet.","For more information on how to use the wallet read the --help section:"]},{"l":"Mining","p":["Mining Warthog's Janushash algorithm requires both, a good CPU and a GPU. Solo and pool miners can be found here:","Janusminer(open source)","We have a guide on how to install OpenCL: Welcome"]}],[{"l":"Links","p":["Algorithm whitepaper"]},{"l":"Socials","p":["Discord","Telegram","Bitcointalk","Reddit"]},{"l":"Explorers","p":["wart.0xf10.com"]},{"l":"Pools","p":["acc-pool"]},{"l":"Miners","p":["Janusminer(open source)"]},{"l":"Wallets","p":["wart-wallet(open source)","Warthog-network-dapp(open source)"]}],[{"l":"Hashes as Numbers","p":["Each hash (32 byte hex string) can be interpreted as a number in the interval [0,1).","For example the hash FFFF...FFFF would correspond to 1-2^ 256 which is almost 1 and","the hash 0000...0000 would correspond to 0.","Note: A hash cannot correspond to exactly 1 but almost 1.","For a block header h we denote","the verus hash interpreted as a number in [0,1) by X(h) and","the triple sha256 hash interpreted as a number in [0,1) by Y(h).","We define the Janushash number J(h) = X(h)Y(h)^{0.7}.","Similar to above where we converted a hash to a number we can do the reverse, i.e. interpret J(h) as a hash, this hash is the Janushash but we will never compute it or work with it, instead we will solely consider the number representation J(h). All theory works with numbers, so implementation only needs to convert hashes to numbers, but not numbers to hashes For convenience we will call the Janushash number also Janushash.","To represent a small number as a hash, one might require more than 32 digits, there exist transcendental numbers which even require infinite digits to be represent exactly. However this is not of interest for us."]}],[{"l":"Condition to solve a block","p":["For target \\tau\\in[0,1] we define the following two conditions a header h must satisfy to have a valid Proof of Balanced Work:","The Sha256t hash must not be too small: Y(h) \\ge c for some constant c=0.005","The Janushash must be below the target: J(h) < \\tau."]},{"i":"implementation","l":"Implementation:","p":["The function to check for valid Proof of Balanced Work can be implemented as follows:","The CustomFloat class has it's own Repository here. It is a portable floating point representation with math functions ( log2, pow2, pow) and supports:","Conversion of a hash into CustomFloat number representation.","Multiplication","Raising a number to some exponent","The use of CustomFloat is necessary since C math library functions cannot be used in consensus-critical parts of a cryptocurrency. This way portatility is guaranteed."]}],[{"l":"Mining","p":["Optimally mining janushash exhausts both, a system's CPU and GPU to their limits. GPU is more efficient at Sha256t computations while CPU is more efficient at Verushash v2.1. Since Sha256t hashrate will usually be larger than Verushash v2.1 hashrate by orders of magnitude, it is important to decide optimally on which headers we evaluate the Verushash v2.1 hash function.","Since Sha256t and Verushash v2.1 are different proper hash functions the result of one does not correlate with the result of the other (mathematically we can model the two hash functions' outcomes as independent). Therefore to minimize the janushash value (which needs to be below the target to mine a block)","verushash(header)*sha256t(header)^0.7","it is best to evaluate verushash on the headers with smallest sha256t values that are still larger than the constant c to match the first mining condition above:","Sha256t(header) > c for some hard-coded constant c.","In particular out of the many GPU computed sha256t hashes we need to select the smallest that are greater than c. We select just as many as the CPU can handle.","This gives us the following approach:"]},{"l":"Mining Approach","p":["Mine sha256t of headers on GPU","Send those headers with sha256t > c and smaller than c + hr_CPU/hr_GPU into a queue that is processed by CPU to evaluate verushash on them.","Compute Verushash v2.1 on these headers","Evaluate janushash number representation verushash(header)*sha256t(header)^0.7 and check if it is smaller than the target t.","Above in 2. we use the quotient of CPU and GPU hashrates on verushash, sha256t respectively. The idea behind the band [c, c+hr_CPU/hr_GPU] is that on average, the number of sha256t hashes that fall into this band will be at rate hr_CPU, so this strategy will produce header candidates in the CPU queue at exactly the rate the CPU can handle.","To evaluate janushash number representation in 4. above, we should copy not only the headers but also the first 4 bytes of the evaluated sha256t hash from GPU device to host memory. Otherwise we would need to evaluate sha256t(header) again."]}],[{"l":"Preliminaries"},{"l":"Distribution of Hashes","p":["A proper hash function should be random in the sense that each output bit cannot be predicted from the input and also cannot be predicted from other bits in its output. Therefore with the interpretation of a hash as a number in [0,1) we can model the Verushash v2.1 X(h) and the Sha256t Y(h) of a header as samples of uniform random variable on [0,1]. Since we use two different hash functions we can model the vector (X(h),Y(h)) as two independent realization of a uniform random variable on [0,1]. This means that the joint distribution is the product measure, i.e. the uniform distribution on [0,1]^2.","We therefore define the random vector(X,Y) to have this uniform probability distribution on [0,1]. Keep in mind that this random vector just models the Verushash v2.1 and Sha256t hashes (interpreted as numbers in [0,1]) of a block header in a probability-theoretic setting."]},{"l":"Acceptance region","p":["Recall the the two conditions to solve a block. Preliminaries An equivalent formulation is to require that (X(h),Y(h)) must be an element of the acceptance region A_{\\tau}\\subset [0,1]^2 defined as","The target controls the difficulty, obviously if the target is decreased then it is more difficulty to mine a block."]},{"l":"More insight on the log scale","p":["If we apply the logarithmic transformation on the acceptance region A_{\\tau}, the condition","can be reformulated as","Recall that x and y are less than 1. This means -\\log(x) and -\\log(y) are positive. We can therefore visualize the acceptance region A_{\\tau} in the first quadrant of a Cartesian coordinate system representing -\\log(x) and -\\log(y) along its axes.","The following figure depicts the situation in log scale, the acceptance region A_{\\tau} is colored light blue:","Acceptance Region"]},{"i":"pushforward-measure-on-log-scale","l":"Pushforward measure on log scale.","p":["On the log scale we consider the transformed vector (-\\log(X),-\\log(Y)). The probability distribution of this transformed vector is the pushforward measure of (X,Y) through the map g: [0,1]^2 \\to \\mathbb{R}_{\\ge0}^2, (x,y)\\mapsto(-\\log(x),-\\log(y)). Note that by independence of X and Y","Since the Borel \\sigma-algebra on \\mathbb{R}_{\\ge 0}^2 is generated by the sets [0,x]\\times [0,y], x,y\\in\\mathbb{R}_{\\ge0} this proves that the pushforward measure is the product measure of two identical exponential distributions.","With this info we can do probability-theoretic calculations on the log scale."]}],[{"l":"Mining Probability","p":["Recall that a block is rejected if the Sha256t hash of its header is too small, i.e. if Y< c. Furthermore, the smaller Y the easier it is to satisfy the second condition XY^{0.7}< \\tau because larger, and therefore easier-to-mine Verushash v2.1 hashes are accepted.","Now consider a specific mining setting. We denote the Verushash v2.1 hashrate by \\mathfrak{h}_X and the Sha256t hashrate by \\mathfrak{h}_Y. For simplicity we will call \\mathfrak{h}_X the CPU hashrate and \\mathfrak{h}_Y the GPU hashrate because these are the devices that the respective algorithms are typically mined on at the moment. We will denote the \\frac{\\mathfrak{h}_Y}{\\mathfrak{h}_X} by a and since GPU hashrate is usually greater than CPU hashrate a will be greater than 1. We call this number the hashrate ratio.","To match CPU hashrate, hashes computed on GPU must be filtered, and from the discussion above a reasonable filter condition is to compute Verushash v2.1 on headers h that satisfy","This way we would select fraction 1/a of GPU hashes to check Verushash v2.1 on the corresponding headers. The fraction 1/a of GPU hashrate will exactly match the CPU hashrate such that filtered GPU results will come at the right rate to be processed by CPU.","Note that this is only true for a > (1-c)^{-1}, for the small range between 1 and (1-c)^{-1}(which is only a tiny bit larger than 1) the above reasoning would need to treat the case where filtering cannot avoid that some GPU hashes are rejected for Y being smaller than c if we want to match CPU rate. In this case CPU and GPU hash rates are just too close to allow enough filtering. But we ignore this small range for now as usually GPU hash rate on Sha256t is orders of magnitude larger than CPU hashrate on Verushash v2.1.","For some number d \\in [c,1] it holds that","We denote the conditional probability to mine a block for Y(h) filtered to be in the interval [c, c+1/a] by p_{\\tau}(a). If we plug in d=c+1/a above, we observe that"]}],[{"i":"janusscore---a-combined-hashrate-equivalent","l":"Janusscore - a combined hashrate equivalent","p":["We define the Janusscore S(\\mathfrak{h}_X,\\mathfrak{h}_Y) for Verushash v2.1 hashrate \\mathfrak{h}_X and Sha256t hashrate \\mathfrak{h}_Y by","With this definition we can express the expected number mined blocks with traget \\tau in time t as","This means two things:","For every target \\tau the expected number of mined blocks in time t is proportional to S(\\mathfrak{h}_X,\\mathfrak{h}_Y) and therefore S(\\mathfrak{h}_X,\\mathfrak{h}_Y) describes the mining efficiency.","S(\\mathfrak{h}_X,\\mathfrak{h}_Y) takes the role of a hashrate. For example one can estimate the Janusscore S by dividing the number of mined blocks by the time and the target (this can be used in pools to estimate the Janusscore based on number of shares, time and difficulty).","The Janusscore the unit \"hashes per second\" and can be interpreted as a hashrate equivalent to compare different setups.","Increasing one of the hashrates of \\mathfrak{h}_X, \\mathfrak{h}_Y while leaving the other constant will always increase the Janusscore."]},{"l":"Python code to compute the Janusscore"},{"l":"Julia code to compute the Janusscore"}],[{"l":"Hashrate Ratio","p":["The hashrate ratio is the quotient a of Sha256t hashrate \\mathfrak{h}_Y and Verushash v2.1 \\mathfrak{h}_X:"]},{"l":"Hashrate Ratio Boost","p":["The Janusscore satisfies","with","for a\\ge 1(again mind the small range [1,(1-c)^{-1}] where the reasoning is not correct). We therefore call \\gamma(a) the hashrate ratio boost for hashrate ratio a. It is a multiplicative factor applied to a hypothetical reference Janusscore S(\\mathfrak{h}_X,\\mathfrak{h}_X) to express S(\\mathfrak{h}_X,\\mathfrak{h}_Y). The function \\gamma looks like this:","Acceptance Region","There is a limit on the hashrate ratio boost:","where we used L'HÃ´pital's rule in the third step and finally plugged in the constant c = 0.005. This means that hashrate ratio boost cannot go above \\approx 15.35 no matter how much Sha256t hashrate is thrown into the game. The higher the hashrate ratio of GPU/CPU hashrates, the more CPU, i.e. Verushash v2.1 hashrate becomes the bottleneck.","This is intended and protects Warthog against ASICs applied to Sha256t. Such mining behavior will suffer heavily from being bottlenecked by CPU hashrate."]},{"l":"Julia code to plot this function"},{"l":"Estimating Hashrate Ratio from mined blocks","p":["The conditional density p_{Y,a} of Y given (X,Y)\\in A_{\\tau} and Y\\in [c,c+\\tfrac{1}{a}] is proportional to","for y\\in[c, c+\\frac{1}{a}]. Note that again this does not depend on the target \\tau. The conditional expectation is","If we have N blocks mined from a specific address we can consider their Sha256t hashes y_1,\\ldots,y_N to compute the empirical expectation (mean) \\bar{y}=N^{-1}\\sum\\limits_{i=1}^{N} y_i.","The method of moments can be used to get an estimate \\hat a of the hashrate ratio a from observed Sha256t average \\bar{y}. To do this we must find a such that the empirical expectation observed from the blocks and the conditional expectation match:","Unfortunately this can only be solved numerically, we cannot express the solution analytically. Since the hashrate ratio a is in the range [1,\\infty], the maximal conditional expectation is attained for a=1, if we observe an empirical mean \\bar y larger than this number","we just estimate \\hat a=1, otherwise we solve the above equation numerically. In the following code we cap estimation at factor 100000:"]},{"l":"Python code to estimate hashrate ratio"}],[{"l":"Compiling Warthog from source on Linux","p":["Compiling Warthog from soure is an alternative to the use precompiled binaries."]},{"l":"Installing required packages","p":["Before we can start make sure you have a recent Linux distribution. In this guide we are using Ubuntu 22.04.3 LTS. We need to update our package manager and install git, build-essential, meson and ninja-build:"]},{"l":"Cloning the Repo","p":["Now that we have git we can clone the Warthog repository from GitHub:"]},{"l":"Compiling","p":["A new directory should be created, let's cd into it and run meson build to create a build directory named build:","When you run the meson build command for the first time some extra dependencies will be downloaded so it might take a while. Now we have a build directory within the Warthog directory so we cd into it and start compilation with ninja:","Congratulations! You now have compiled the Warthog C++ source. But wait - there is a problem: we did not enable compiler optimizations. In meson compiler optimizations need to be explicitly enabled with the --buildtype=release flag. Then the compiled executables and libraries will be more efficient. This is important for mining because you will get better hashrate with optimized compilation.","So let's do this again, we will go up one directory and delete the build directory again. Then we recreate it but this time with the --buildtype=release option and compile again with ninja:","Note that now meson reports it has set buildtype: release.","After compilation finished successfully we can have a look at the compiled artifacts: Warthog currently compiles a node, a wallet and a miner. They are generated in the src directory within the build directory. Have a look:"]}],[{"l":"How to start a Warthog node as a systemd service","p":["NOTE: This is only supported in Linux distros that use systemctl(Debian, Ubuntu, Mint etc.).","Enable auto restart when logged off (only need to do this once per machine): $ sudo loginctl enable-linger $USER","Create the directory structure: $ mkdir -p ~/.config/systemd/$USER","Create a file with the following content at that directory, file path: ~/.config/systemd/$USER/warthog.service","Reload systemctl daemon: systemctl --user daemon-reload","Enable auto restart for Warthog service: systemctl --user enable warthog","Start for Warthog service: systemctl --user start warthog","Check status for Warthog service: systemctl --user status warthog"]},{"l":"How to start a public node","p":["You need to have a static IP. Do as above but append the --enable-public flag at startup, i.e. use this file content:"]}],[{"l":"OpenCL Installation","p":["To mine on your GPUs you need to install GPU drivers with OpenCL support.","You can check whether your GPU has a working OpenCL support with the clinfo command. Install this program with","Then start it by typing","In our case we don't have any GPU drivers installed that support OpenCL:","The installation procedure depends on your GPU vendor."]},{"l":"AMD GPUs","p":["Our GPU is an AMD Radeon RX 5600 XT but clinfo does not detect any OpenCL installation for it yet. Visit the AMD support site https://www.amd.com/en/support and select the GPU model:","Then we need to install the downloaded deb package.","This will command will take a while downloading and installing more than 2GB worth of packages.","Now try clinfo agian:","The AMD OpenCL platform is now detected but there are no devices. This is because you need to add your user to the render group:","Now reboot your system. If you try clinfo again you now see the GPU device:"]},{"l":"NVIDIA GPUs","p":["First download your driver from https://www.nvidia.de/Download/index.aspx?lang=en-us by selecting your GPU model and clicking on \"Aggree Download\".","The downloaded file is a sh script and we need to make it executable. So we navigate to the Downloads directory and execute","Of course you need to insert your exact filename here. When we try to run it via","we get this error:","This means we need to execute the script no a lower run level without an X server running. In addition we must blacklist the default nouvaeu driver with this command:","Now reboot your system. Once rebooted you should switch to a lower run level. To do this press the three keys CTRL + ALT + F3 at the same time. You should see a black screen with login prompt like this:","Log in with your user name and password and then switch to a lower run level with","You can now start the installation as above, navigate to the Downloads directory and start the installation:","You should see these screens, just select \"Confirm installation\", then \"Yes\", \"Yes\", \"OK\".","Now that the NVIDIA driver installation is complete restart your system again you should be able to see your device in the clinfo command:"]}],[{"l":"Pool Integration"},{"l":"Share validation","p":["I have written a C++ backend which support computes the hash product","Verushash(header)* Sha256t(header)^ 0.7","This is a number between 0 and 1. If the first condition","Sha256t(header) > c for some hard-coded constant c.","is not met it returns 1. This is a convenient way for pools to check valid shares: Instead of using the block real target, the pool would set an easier difficulty in Stratum jobs, which corresponds to a larger target t^* than the block target t. A share is valid if the hash product returned by the backend is smaller than t^*. If the returned value is 1 as is done by the backend if the first condition above is not met, the share is automatically invalid because t^* will be between 0 and 1.","The pool backend has two endpoints:","/score/:headerhex: It computes the score above (hash product). For performance the score is not embedded into json encoded but directly returned. On error an empty string is returned. headerhex is the hex encoded header (80 bytes = 160 bytes hex encoded).","/target_to_double/:targethex: It converts the block target from byte representation to double. This is important to check if the score actually solves a block."]},{"l":"Block structure","p":["Each block consists of a 10 extranonce bytes followed by 3 sections:"]},{"i":"1-new--address-section-2n120-bytes","l":"1. New address section (2+n1*20 bytes)","p":["This section starts by encoding the number n1 of new addresses registered in this block, then n1 elements of 20 bytes each follow."]},{"i":"2-reward-section-16-bytes","l":"2. Reward section (16 bytes)","p":["This section encodes the mining reward (miner + amount)."]},{"i":"3-transfer-section-4n399-bytes","l":"3. Transfer section (4+n3*99 bytes)","p":["It starts by encoding the number n3 of transfers in a 4 byte network byte order integer. Then follow n3 entries of 99 bytes each, one for each transfer. If n3 is 0 then the transfer section is omitted completely, in this case it is 0 bytes long. Miner devs can detect this by comparing the current cursor with the end of the block byte vector when parsing the sections of a block."]},{"l":"Merkle Root Computation","p":["Merkle tree has the n1 + 1 + n3 elements of the three sections as its leaves: n1 20 byte elements, one 16 byte element and n3 99 byte elements. The Merkle tree uses sha256 to combine two elements into one in each hierarchy level.","Merkle root is computed this way:","In the last step we append the 10 byte extranonce space from the beginning of the block to the hashed data for the final hash. The data we append these 10 extranonce to we call merklePrefix. The Merkle root is therefore sha256(merklePrefix + extranonceBytes). The merklePrefix is transmitted in the Stratum protocol. It is either 32 bytes or 64 bytes long. Only if you have 1 leaf in the Merkle tree, the Merkle prefix will be 32 bytes, otherwise the Merkle prefix will be the two children of the root concatenated."]},{"l":"Scanning the Chain","p":["Pool Integration"]},{"l":"Pool Payout","p":["Pool Integration"]},{"l":"Miners for Testing","p":["Pool Integration"]}],[{"l":"Stratum Protocol","p":["Messages are newline (\\n) terminated json strings sent over plain TCP with optional TLS encryption. URI scheme is stratum+tcp for plain TCP and stratum+ssl or stratum+tls if TLS encryption is used (for some reason \" ssl\" is more prevalent than \" tls\" as URI scheme despite in fact TLS is actually used)."]},{"l":"Establishing a stratum connection","p":["After establishing a TCP connection (and optionally TLS) the first message is sent from the Client and must be of type mining.subscribe:"]},{"i":"miningsubscribe","l":"Mining.subscribe"},{"i":"request-from-client","l":"Request from client:"},{"i":"response-from-pool","l":"Response from pool:"},{"l":"Mining authorize","p":["The next message is again send from the client and must have method field equal to mining.authorize:"]},{"i":"request-from-client-1","l":"Request from client:"},{"i":"response-from-pool-1","l":"Response from pool:","p":["Now the connection is established. The pool n"]},{"l":"Events pushed from pool server to clients","p":["There are two kind of events that sent from the pool: mining.notify and mining.set_difficulty."]},{"i":"miningnotify","l":"Mining.notify"},{"i":"notable-differences-from-bitcoins-stratum-protocol","l":"Notable differences from Bitcoin's Stratum protocol:","p":["This method has only 7 parameters instead of 9 parameters in Bitcoin's stratum protocol. Bitcoin's stratum protocol's third (coinbase 1) and fourth (coinbase 2) parameters are not necessary in Warthog. Furthermore instead of Bitcoin's Merkle branches parameter we have a Merkle prefix parameter. Merkle root is computed as follows:"]},{"l":"Merkle root computation","p":["Merkle root is sha256(merklePrefix + extranonce1 + extranonce2). Miners can choose extranonce2 arbitrarily (with length specified by pool) to generate different Merkle roots."]},{"l":"Header structure","p":["The parameters sent in a mining.notify event and a 4-byte nonce selected by the miner can be used to form a header to be hashed by the miner as follows:","Bytes","Meaning","1-32","prevHash","33-36","nbits","37-68","Merkle root (controlled by miner, see above)","69-72","version","73-76","ntime","77-80","nonce (chosen by miner)"]},{"i":"miningset_difficulty","l":"Mining.set_difficulty"},{"i":"notable-differences-from-bitcoins-stratum-protocol-1","l":"Notable differences from Bitcoin's Stratum protocol","p":["In contrast to Bitcoin's stratum protocol the target is just the inverse of the difficulty. In Bitcoin there is an additional factor of 2^ 32 involved for historical reasons. Since Warthog was written from scratch, it not carry this historical burden. This means the miner must meet the target 1/difficulty to mine a share."]},{"l":"Events pushed from miner to pool"},{"i":"miningsubmit","l":"Mining.submit","p":["When the miner has found nonce and extranonce2 such that the block is","Pool will reply with","or report error."]},{"l":"Error reporting","p":["Pool response must specify request id in the id field. Errors are reported by setting result to null and specifying error details in an array of size 3 (code, message, additional info) in the error field.","01/21/2024 6:07 PM Every coin has its own stratum specification and I changed just very little. Basically we do not have coinbases but mining.notify looks like this:"]}],[{"l":"Miner Integration"},{"l":"Condition to Mine a Block","p":["Miner Integration"]},{"l":"Mining Strategy","p":["Miner Integration"]},{"l":"Stratum Protocol","p":["Miner Integration"]},{"l":"Reporting Hashrate","p":["Miners should report Sha256t and Verushash v2.1 measured hashrates and in addition to that they should report the Janusscore. Janusscore describes the mining efficiency (combined hashrate) and can be computed from sha256t and verushash hashrate variables as follows:","Miner Integration"]},{"l":"Pools for testing","p":["Miner Integration"]}],[{"l":"Wallet integration","p":["In this guide we demonstrate how to handle wallets and send transactions in Python 3, NodeJS and Elixir."]},{"l":"Prerequisites","p":["We use the pycryptodome and pycoin Python packages.","We use the elliptic, node:crypto, sync-request and secp256k1 NodeJS packages.","We use the {:curvy, ~ 0.3.1}, {:jason, ~ 1.4} and {:httpoison, ~ 2.0} Hex packages."]},{"l":"Handling wallets","p":["Below we demonstrate how to","generate a new private key,","load a private key from hexadecimal encoding,","derive a public key from a private key,","derive a raw Warthog address form a public key and","extend the raw Warthog address by its checksum to obtain an ordinary Warthog address."]},{"i":"generating-signing-and-sending-a-transfer-transaction","l":"Generating, signing and sending a transfer transaction","p":["In Warthog transactions are pinned to a specific block the blockchain. The height of this block is its pinHeight, its hash the pinHash. This information has to be retrieved from the node in order to start generating a transaction, a transaction with a pinHeight that is too old be discarded. This serves two purposes","Users can be sure that transactions will not be pending forever.","By choosing a particular pinHeight users can actively control the time to live (TTL) of a pending transaction before it is discarded.","Not all height values are valid pinHeights, instead they must be a multiple of 32. For convenience the /chain/head endpoint provides the latest pinHeight value together with the corresponding block hash pinHash. In our code sample below we will use this endpoint.","In addition we demonstrate how to create the bytes to sign, how a valid sekp256k1 recoverable signature in custom format is generated and how to send the transaction to the Warthog node via a HTTP POST request. For reference read the API guide. The below code uses the private key pk variable from the above code snippet.","Javascript does not support 64 bit integers natively, one has to resort to BigInt, which does not serialize as a JSON number required by the API. Therefore we are just serializing a normal Javascript number which will only be accurate up to 15 digits, i.e. only 7 figure WART amounts can be precisely handled this way because Warthog has a precision of 8 digits after comma. The total hard cap of WART is 18m which is a 8 figure number, so practically the 7 figures should be sufficient for most purposes."]}],[{"l":"API"},{"l":"Configuration","p":["API is accessed via the RPC endpoints of the node. The endpoints socket can be configured via the --rpc command line option:","For example invoke","to start the node with RPC listening on all devices on port 3000.","The RPC endpoint should not exposed to the internet, use appropriate firewall settings.","Below we assume the RPC socket is accessible at localhost:3000. On startup the node reports the RPC endpoint setting:"]},{"l":"Endpoint Overview","p":["/account/:account/balance","/account/:account/history/:beforeTxIndex","/chain/append","/chain/block/:id","/chain/block/:id/hash","/chain/block/:id/header","/chain/grid","/chain/hashrate","/chain/head","/chain/mine/:address","/chain/signed_snapshot","/chain/txcache","/peers/banned","/peers/connect_timers","/peers/connected","/peers/endpoints","/peers/ip_count","/peers/offenses/:page","/peers/unban","/tools/encode16bit/from_e8/:feeE8","/tools/encode16bit/from_string/:feestring","/transaction/add","/transaction/lookup/:txid","/transaction/mempool","Append mined block","DESCRIPTION","Generate data required for mining","GET","METHOD","PATH","POST","Round coin amount string to closest 16 bit representation (for fee specification)","Round raw 64 integer to closest 16 bit representation (for fee specification)","Send transactions","Show balance of specific account","Show banned peers","Show chain snapshot","Show content of mempool","Show current hashrate","Show hash of specific block","Show header and body of specific block","Show header grid (used for sync)","Show header of specific block","Show info of connected peers","Show info on chain head","Show known peer endpoints","Show offenses of peers","Show peer IPs","Show timers used for reconnect","Show transaction cache","Show transaction history of specific account","Transaction lookup","Unban all peers","You can see an HTML overview of all supported RPC endpoints by opening localhost:3000 in your browser. Currently the following endpoints are supported:"]},{"l":"Detailed Description"},{"i":"post-transactionadd","l":"POST /transaction/add","p":["amount (optional)","Amount of coins to send multiplied by 10^ 8. For example to send one coin this value must be 100000000.","Amount of coins to send. Format must be string, non-scientific notation with at most 8 digits after comma. \"1\" or \"1.00000000\" are valid.","Amount of coins to spend on transaction fees multiplied by 10^ 8. For example to send one 0.00000001 coins this value must be 1. This value must be exactly representable value in a 16 bit encoding, see below.","Amount of coins to spend on transaction fees. This value must be exactly representable value in a 16 bit encoding, see below.","amountE8 (optional)","DETAILS","fee (optional)","feeE8 (optional)","hex-encoded 65 byte compact recoverable ECDSA signature in custom format, see below.","Miner fee must be exactly representable in a 16 bit encoding.","nonceId","NOTE:","PARAMETER","pinHeight","Send transactions in JSON format:","Signature includes block hash at this height","signature65","string","string of length 130","string of length 48","The address that coins shall be transferred to","The transaction fee must be specified either via fee or via feeE8.","The transfer amount must be specified either via amount or via amountE8.","To avoid double spend, there can only be one transaction with a specific (pinHeight,nonceId) pair. The same nonceId can be used for different pinHeight values","toAddr","TYPE","unsigned 32 bit integer","unsigned 64 bit integer"]},{"l":"Details on fees","p":["Fees are not subtracted from the amount sent in the transaction. The sender spends both, transfer amount and transaction fee, toAddr receives the transferred amount and the miner of the block including this transaction gets the transaction fee.","For efficiency and compactness transaction fees are internally encoded as 2-byte floating-point numbers (16 bits), where the first 6 bits encode the exponent and the remaining 10 bits encode a 11 bit mantissa starting with an implicit 1. Of course not every 64 bit value can be encoded in 16 bits and only fee 64 bit values which are representable exactly in the 16 bits encoding are accepted. You can use the /tools/encode16bit/from_e8/:feeE8 or /tools/encode16bit/from_string/:feestring endpoints to round an arbitrary 64-bit fee value to an accepted 64 bit value."]},{"i":"how-to-specify-the-sender","l":"How to specify the sender?","p":["The sender's address is recovered from the recoverable ECDSA signature signature65. It is implicitly specified by creating a signature with the corresponding private key."]},{"l":"Signature generation","p":["1 -32","33-36","33-64","37-40","41-43","44-51","52-71","65","72-79","amountE8( uint64_t in network byte order)","BYTES","Call the /chain/head endpoint and extract the pinHash and pinHeight fields.","Compute transaction hash. The transaction hash is the SHA256 hash of the following bytes:","Concatenate the parameters to form the 65-byte compact normalized (lower s) recoverable signature with the following byte structure:","DESCRIPTION","feeE8( uint64_t in network byte order)","Generate the secp256k1-ECDSA recoverable signature of the 32-byte transaction hash using the private key corresponding to the sender's address. The signature will have three properties:","nonceId( uint32_t in network byte order)","Note that this is not the standard compact recoverable signature representation because in Warthog, the recoverable id is the last byte of the 65 byte signature and has no offset of 27.","pinHash(hash of block at height pinHeight)","pinHeight( uint32_t in network byte order)","r","r: 32 byte coordinate parameter","recid","recid: 1 byte recovery id, it should automatically have one of the four values 0,1,2,3.","reserved(3 bytes containing 0)","s","s: 32 byte coordinate parameter","The following steps are required:","toAddr receiving address (20 bytes without the final 4 byte checksum)"]},{"l":"Integration guides","p":["We provide working code snippets on how to generate and send transactions in Python3, Elixir and NodeJS."]},{"i":"post-transactionadd-1","l":"POST /transaction/add","p":["Send transactions in JSON format, returns transaction hash in hex format:"]},{"i":"get-transactionmempool","l":"GET /transaction/mempool","p":["Show content of mempool. Example output:"]},{"i":"get-transactionlookuptxid","l":"GET /transaction/lookup/:txid","p":["Transaction lookup by transaction id. Example output of /transaction/lookup/4b3bc48295742b71ff7c3b98ede5b652fafd16c67f0d2db6226e936a1cdbf0a5:"]},{"i":"get-chainhead","l":"GET /chain/head","p":["Show info on chain head. Example output:"]},{"i":"get-chaingrid","l":"GET /chain/grid","p":["Show hexadecimal header grid. This grid is used for chain sync to allow nodes spot points where chains diverge. Example output (truncated):"]},{"i":"get-chainsigned_snapshot","l":"GET /chain/signed_snapshot","p":["Show chain snapshot. Example output"]},{"i":"get-chainblockidhash","l":"GET /chain/block/:id/hash","p":["Show hash of specific block. Example output of /chain/block/366700/hash"]},{"i":"get-chainblockidheader","l":"GET /chain/block/:id/header","p":["Show header of specific block.","Example output of /chain/block/366700/header"]},{"i":"getchainblockid","l":"GET/chain/block/:id","p":["Show header and body of specific block. Example output of /chain/block/366700"]},{"i":"get-chainmineaddress","l":"GET /chain/mine/:address","p":["Generate data required for mining. Example output of /chain/mine/e4145cfe3e34f206956487c2a16b65a47f05fc347ef6e287"]},{"i":"get-chaintxcache","l":"GET /chain/txcache","p":["Show transaction cache. Example output:"]},{"i":"get-chainhashrate","l":"GET /chain/hashrate","p":["Show current hashrate","Note this endpoint is currently deprecated since the algorithm update, it will need some research and math."]},{"i":"post-chainappend","l":"POST /chain/append","p":["Append mined block. Miners must POST mined block they received from GET /chain/mine/:address. TODO: Detailed description"]},{"i":"get-accountaccountbalance","l":"GET /account/:account/balance","p":["Show balance of specific account. Example output:"]},{"i":"get-accountaccounthistorybeforetxindex","l":"GET /account/:account/history/:beforeTxIndex","p":["Show transaction history of specific account Example output:"]},{"i":"get-toolsencode16bitfrom_e8feee8-round-raw-64-integer-to-closest-16-bit-representation-for-fee-specification","l":"GET /tools/encode16bit/from_e8/:feeE8| Round raw 64 integer to closest 16 bit representation (for fee specification)","p":["Round raw fee integer representation (coin amount is this number divided by 10^ 8) to closest 16 bit representation. This is required for fee specification in the /transaction/add endpoint. Example output of /tools/encode16bit/from_e8/5002"]},{"i":"get-toolsencode16bitfrom_stringfeestring","l":"GET /tools/encode16bit/from_string/:feestring","p":["Round fee amount string to closest 16 bit representation. This is required for fee specification in the /transaction/add endpoint. Example output of /tools/encode16bit/from_string/0.001:"]},{"l":"WIP Websocket","p":["Raw blocks, so rollbacks are not tracked, this must be added in future to have complete incremental chain change feed.","Exemple output :"]}],[{"i":"warthog---an-experimental-fresh-rewrite-of-a-pow-cryptocurrency","l":"Warthog - An experimental fresh rewrite of a PoW cryptocurrency","p":["This white paper is a work in progress."]},{"l":"Introduction and Project goals","p":["Warthog is a classical Proof-of-Work (PoW) based cryptocurrency which is meant to be a fun and experimental side project of its developers Pumbaa, Timon and Rafiki who work in blockchain industry.","We are working on Warthog in our free time and there is always the risk that we leave due to time constraints or personal reasons. In fact our colleague Timon has already left the team. Therefore we are trying to build up a strong community backing the project.","Mainly one can describe this project as an experiment to try out new things and learn how blockchain technology works in detail. But at the same time we want to be as transparent and fair as possible and avoid as much as possible fishy and questionable practice currently seen in most other new projects.","The code is freshly written in C++ 20 and is not a cheap fork of any other project. Therefore there is always the risk of serious or unfixable bugs. But at the same time there is real effort put into this project which sets it apart from most competitors.","The community is welcome to take actively part in the evolution of Warthog, the logo and the explorer are made by volunteers and also possible choices for a mining algorithm are proposed. The connection with the community shall be preserved and extended in the future. If you want to join, please do so!","There is no specific purpose or use case of Warthog. However we want to revive the days when crypto was a fun and an interesting experimental thing. One of our experiments with this project is to use SQLite to store blocks and state. Another is the completely novel idea of syncing nodes via chain descriptors instead of asking other nodes for blocks by their hashes.","One design principle of Warthog is fast sync speed and a low impact on system resources which is achieved by the use of fast hashing algorithms, appropriate data structures and our custom-built sync algorithm.","For now and in the near future the primary plan is to make the node implementation more robust and improve infrastructure like explorer and API for better interoperability."]},{"l":"Technical Details"},{"l":"Retarget Logic","p":["Similarly to Bitcoin, the warthog blockchain will scale its difficulty periodically to adjust for changing hashrate. Changes in difficulty is partitioned into two phases:","In the initial phase the difficulty is adjusted every 720 blocks which corresponds to approximately 4 hours.","In the second phase the difficulty is adjusted every 8640 blocks which corresponds to 2 days.","The reason for this two-phase approach is the high variability of hashrate in early stages of a project's life which initially requires a more frequent difficulty adjustment. On the other hand too short intervals also have disadvantages such as the tendency to oscillate and a possibly higher impact of faked timestamps. Therefore the second phase stretches the difficulty adjustment interval after the initial phase.","While in Bitcoin the difficulty change is capped by factor 4, we have implemented a factor 2 cap because our difficulty adjustment is more frequent than 2 weeks."]},{"l":"Emission Scheme","p":["% of total supply in circulation","~ June 29 2024","~ June 29 2025","~ June 29 2026","~ June 29 2027","0 years","0%","1 years","2 years","25%","3 years","4 years","50%","62.5%","75%","Before halving occurs every block yields 3 WART as miner reward. Since the block time is 20 seconds, every day approximately 60/20 * 60 * 24 = 4320 blocks and 12960 WART are mined before halving.","Date","June 29 2023","Lifetime","There is no tail emission which means there is a hard cap of the amount in circulation. The hard cap is 18921599.68464 WART (around 19 million coins).","Warthog was started without any premined or reserved amount of coins on June 29, 2023. The project implements a classical halving-based emission scheme with halvings occurring every 3153600 blocks (every 2 years). The emission for the next 4 years is summarized in the following table:"]},{"l":"Coin Precision","p":["The reference implementation uses the C++ data type uint64_t for storing amounts of WART. This is a 64 bit unsigned integer. To represent fractions of a coin these values are interpreted in fixed point arithmetic with 8 digits precision. This means that 1 WART is internally represented as uint64_t number with value 100000000. The smallest representable step is 0.00000001 WART and represented as uint64_t number with value 1.","For easier integration all API endpoints return both, the WART amount as a string (like amount: 12.0), and the internal integer representation indicated with label \" E8\" (like amountE8: 1200000000)."]},{"l":"One-of-a-kind chain descriptor based sync","p":["This project is an experiment where the developers try out new things and push the boundary of what is possible in blockchain technology. We invented a completely unique and new way of syncing nodes which is not presently not known to the industry.","Traditionally during synchronization new nodes request block bodies identified by block hashes. The replying node has to look up the block body based on the hash and then sends it back.","In contrast we have invented a node communication protocol which works without block hashes for block body lookup. In our setup nodes keep track on fork heights with other nodes. A chain descriptor is used to identify a specific chain on the peer. When a node appends to its chain, the chain descriptor remains unchanged, however the current chain descriptor is increased when the consensus chain switches to a longer fork. Block bodies for previous chains are also kept for some time in case a peer requests them.","When syncing nodes request block bodies identified by a chain descriptor and a block range. This way we avoid overhead in communication and lookup."]},{"l":"SQLite backed block store","p":["SQLite is a battle-proven and well-established embedded SQL database engine. Warthog nodes use SQLite as their main storage engine for both, blocks and state. Nodes also index transactions and can provide basic blockchain explorer functionality directly via API thanks to SQLite.","SQLite databases are also portable across 32-bit and 64-bit machines and between big-endian and little-endian architectures such that chain snapshots can easily shared. Furthermore SQLite supports transactions which are essential for data integrity even in case of a power outage or node crash.","The default SQLite database file name used for the chain is chain.db3 and can be configured via the --chain-db command line option"]},{"l":"Account based architecture","p":["Warthog implements an account based architecture. This is similar to Ethereum and different from Bitcoin's UTXO model. Every account along with its balance is stored in the State table of the chain database. For efficiency reasons accounts are referred by their id: Every account is assigned a unique auto-incremented id value on first use. This makes blocks more space-efficient since a block id only requires 8 bytes of storage whereas an address would require 20 bytes."]},{"l":"Anatomy of a block","p":["The binary content of a block is a concatenation of the following sections in their specified order:","Mining section","New address section","Reward section","Transfer section","Below we describe the above sections. All numbers and id values are in network byte order."]},{"l":"Mining section","p":["This section allows miners to put 4 bytes of arbitrary data to affect the merkle hash.","byte range","content","1-4","arbitrary data"]},{"l":"New address section","p":["This section lists new addresses that receive payments in this block and therefore need to be added to the state table. This way they will be assigned a new id value which is referenced in the other sections to specify a particular account.","byte range","content","1-4","number n of new addresses","5-(4+n*20)","n addressess of 20 bytes each","Miners are responsible to ensure that the addresses appearing in the new address section are not already present in the state table and are actually referenced in this block. Otherwise the block is considered invalid."]},{"l":"Reward section","p":["Mining reward is distributed to at least one reward address.","byte range","content","1-2","number r of reward entry","3-(4+r*16)","r reward entries","Every reward entry consists of 16 bytes:","1-8","accountId","9-16","amount","The sum of the amounts received by the addresses listed in the mining reward section must not exceed the total mining reward (block reward + transaction fees), otherwise the block is considered invalid.","The total size of the mining section is 2+ r*16 bytes."]},{"l":"Transfer section","p":["1-4","1-8","17-18","19-26","27-34","35-99","5-(4+t*99)","9-16","amount","byte range","content","Each payment entry has length 99 bytes. Compare this to the average transaction size of around 200 bytes per Bitcoin transfer.","Every transfer entry has the following structure:","fee","fromAccountId","number t of transfer entries","pinNonce","recoverable signature (65 bytes)","t transfer entries","The transfer section contains the transfers made in this block. Its binary outline is as follows:","toAccountId"]},{"l":"Fee specification","p":["For efficiency and compactness transaction fees are encoded as 2-byte floating-point numbers (16 bits), where the first 6 bits encode the exponent and the remaining 10 bits encode a 11 bit mantissa starting with an implicit 1. This means that fee values cannot be 0 and are of lower precision than regular amount values which use 4 bytes. A fee of value of 0 specified on transaction generation will automatically transform into the minimal fee value of 0.0000001 WART."]},{"l":"Project Links","p":["Bitcointalk","GitHub","Discord","Website","Explorer"]}]]